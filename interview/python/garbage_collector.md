# Garbage Collector interface

* Python 的垃圾回收機制主要基於引用計數（Reference Counting）和循環垃圾回收（Cycle Garbage Collection）來管理內存中的變數和對象。

# 引用計數（Reference Counting）
* 每當一個變數或對象被創建時，Python 會自動跟蹤有多少個變數引用了這個對象，這個數量就是「引用計數」
* 當引用計數變為零時，Python 會自動釋放該對象所佔用的內存。

## 原理
* 當一個對象被創建，該對象的引用計數會設置為 1。
* 每當一個新的變數指向這個對象，引用計數就會增加。
* 每當一個變數不再指向這個對象（例如變數被重新賦值或者刪除），引用計數就會減少。
* 當引用計數減到 0，表示不再有變數引用這個對象，Python 會自動回收該對象的內存。

## 簡單例子
``` python
a = []  # 創建列表，引用計數為 1
b = a   # b 引用 a，引用計數增加到 2
del a   # 刪除 a，引用計數減到 1
del b   # 刪除 b，引用計數減到 0，此時列表會被自動回收
```


# 循環垃圾回收（Cycle Garbage Collection）
* 引用計數機制的缺點是無法處理循環引用的情況。
* 例如，兩個對象相互引用，儘管它們已經不再被其他變數使用，但它們的引用計數永遠不會變為 0，導致內存洩漏。
* Python 的循環垃圾回收機制可以檢測到這種循環引用，並將其回收。
* 它會周期性地掃描那些有循環引用的對象，並通過判斷它們是否還有外部引用來決定是否回收它們。

## 循環引用的例子
``` python
class Node:
    def __init__(self):
        self.next = None

a = Node()
b = Node()
a.next = b
b.next = a  # a 和 b 形成了循環引用

# 即使 a 和 b 被刪除，只代表他們的變數跟引用關係不見，但在記憶體裡面，兩者的引用仍然存在
# 循環垃圾回收會處理這個問題
del a
del b 
```

## 垃圾回收模塊（gc 模塊）
* Python 提供了內建的 gc 模塊來手動控制垃圾回收行為，可以啟動或停止循環垃圾回收，檢測哪些對象未被回收，甚至調整垃圾回收的頻率。
* 要精準控制記憶的時候就會用到gc模組
``` python
import gc

gc.collect()  # 手動執行垃圾回收
```
# 總結
* 引用計數：主要機制，當對象的引用計數變為 0 時，內存會被自動釋放。
* 循環垃圾回收：輔助機制，處理引用計數無法解決的循環引用問題，確保內存不會洩漏。