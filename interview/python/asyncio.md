# 協程（Coroutines）總結

## 1. 協程函數 (`async def`)

- 使用 `async` 關鍵字定義協程函數，使其能夠在內部使用 `await` 來等待異步操作。
- 協程函數調用後返回一個協程對象，而不會立即執行。

## 2. 協程對象

- 協程對象是協程函數調用後返回的結果，需要在事件循環中調度執行。
- 可以使用 `await` 關鍵字等待協程對象的完成。

## 3. `await` 的作用

- `await` 用來等待一個異步操作或協程的完成，使得協程能夠在等待期間讓出控制權給事件循環，實現並發執行。
- 只能在協程函數內部使用 `await`。

## 4. 同步操作與異步操作

- 同步操作會阻塞整個線程，無法與 `await` 配合使用來實現並發。
- 異步操作（如 `asyncio.sleep`）不會阻塞線程，`await` 讓協程在等待異步操作時讓出控制權，從而允許其他協程繼續執行。

## 5. 事件循環 (`Event Loop`)

- 事件循環是協程和異步編程的核心，負責調度和運行協程，處理異步 I/O 事件和計時器等非阻塞操作。
- 類似於 Node.js 的事件循環，但 Python 的 `asyncio` 提供了更豐富的高層 API 和更多的控制方式。

## 6. 運行協程函數

- 協程函數需要在事件循環中運行，可以使用 `asyncio.run` 來啟動事件循環並運行最頂層的協程。
- 也可以使用事件循環的低層次 API 來調度和運行協程對象。

## 例子總結

```python
import asyncio

# 定義協程函數
async def dosomething(num):
    print(f'第 {num} 任務，第一步')
    await asyncio.sleep(2)  # 使用 await 等待異步操作
    print(f'第 {num} 任務，第二步')

# 定義主協程函數
async def main():
    tasks = [dosomething(i) for i in range(5)]
    await asyncio.gather(*tasks)  # 並發運行多個協程

# 使用 asyncio.run 啟動事件循環並運行主協程
asyncio.run(main())
```
這個例子展示了如何定義和運行協程函數，使用 `await` 來等待異步操作，以及如何使用 `asyncio.run` 啟動事件循環來調度協程執行。

## 主要觀念

- **協程函數**是用 `async def` 定義的函數，允許使用 `await` 來等待異步操作。
- **協程對象**是協程函數調用後返回的結果，需要在事件循環中運行。
- **`await`** 用來等待異步操作，讓協程在等待期間讓出控制權，實現並發執行。
- **同步操作** 不能使用 `await` 來變成異步操作，會阻塞事件循環。
- **事件循環** 負責調度和運行協程，處理異步 I/O 事件，類似於 Node.js 的事件循環。
- 協程函數需要在事件循環中運行，可以使用 `asyncio.run` 或其他事件循環 API 來啟動。
- 協程函數可以讓不同協程函數異步執行，協程函數內還是同步執行。
- `async` 的作用是將函數變成協程函數，使其能夠在內部使用 `await`。
- 如果協程函數內沒有 `await`，它的行為就像普通函數一樣，會順序執行其中的代碼，但仍需要在事件循環中運行。


通過這些觀念的理解和應用，可以有效地使用協程和異步編程來編寫高效的並發程序。
內容來自跟GPT討論的結果
